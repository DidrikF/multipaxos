
//UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.

type UDPConn struct {
        // contains filtered or unexported fields
}


import (
	"os"
	"syscall"
	"time"
)

func (c *UDPConn) File() (f *os.File, err error)

func (c *UDPConn) LocalAddr() Addr

func (c *UDPConn) Read(b []byte) (int, error)

func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)

func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)

func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)

func (c *UDPConn) RemoteAddr() Addr

func (c *UDPConn) SetDeadline(t time.Time) error

func (c *UDPConn) SetReadBuffer(bytes int) error

func (c *UDPConn) SetReadDeadline(t time.Time) error

func (c *UDPConn) SetWriteBuffer(bytes int) error

func (c *UDPConn) SetWriteDeadline(t time.Time) error

func (c *UDPConn) SyscallConn() (syscall.RawConn, error)

func (c *UDPConn) Write(b []byte) (int, error)

func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)

func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)

func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)



//Echo client code
/*
type UDPAddr struct {
	IP   IP
	Port int
	Zone string // IPv6 scoped addressing zone
}
*/


package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
)

// SendCommand sends the command cmd with payload txt as a UDP packet to
// address updAddr. SendCommand prints errors to output.
//
// DO NOT EDIT
func SendCommand(udpAddr, cmd, txt string) (string, error) {
	addr, err := net.ResolveUDPAddr("udp", udpAddr) //(*UDPAddr, error)
	if err != nil {
		return "", err //return error if failed to resolve addres
	}
	conn, err := net.DialUDP("udp", nil, addr)  //(*UDPConn, error) opens a UDP connection, a stream implementing Reader and Writer interfaces
	if err != nil {
		return "", err //return error if dial up failed
	}
	defer conn.Close() //A defer statement defers the execution of a function until the surrounding function returns.
	var buf [512]byte //array of 512 bytes
	cmdTxt := fmt.Sprintf("%v|:|%v", cmd, txt) //func Sprintf(format string, a ...interface{}) string  -  Sprintf formats according to a format specifier and returns the resulting string.
						//%v - the value in a default format
	_, err = conn.Write([]byte(cmdTxt)) //send command over the connection - I gues this is a blocking line
	
	if err != nil {
		return "", err
	}
	n, err := conn.Read(buf[0:]) //blocking line - reads message from conn into buf, starting from index 0
	if err != nil {
		return "", err //return error if read failed
	}
	return string(buf[0:n]), nil //return the buffer in string format, but the bytes that were recieved from the server

	//the connection is not closed here!
}

var cmdTypes = []string{
	"UPPER",
	"LOWER",
	"CAMEL",
	"ROT13",
	"SWAP",
}

func clientLoop(udpAddr string) { //localhost:12110
	var (
		//Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. 
		//The specification of a token is defined by a split function of type SplitFunc;
		scanner *bufio.Scanner = bufio.NewScanner(os.Stdin) //ability to read one line at a time, so that we can send multiple commands without exiting the program
		ct      int
		txt     string
		resp    string
		err     error
	)
	for { //infinite loop 
		fmt.Println("Enter command type:")
		for i, ct := range cmdTypes {
			fmt.Printf("%v for %q\n", i+1, ct)
		}
		//this is a blocking operation, wating for us to type somthing into stdin and press enter (new line)
		fmt.Scanln(&ct) // Scanln read from os.Stdin; Similar to Scan() - Scan scans text read from standard input, storing successive space-separated values into successive arguments. 
		if ct < 0 || ct > len(cmdTypes) { //accept number to represent command
			fmt.Println("Error: Unkown command")
			continue //skip the rest of the loop
		}

		fmt.Println("Enter text:")

		//What is the receiver?
		scanner.Scan() //Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. 
		
		txt = scanner.Text() //Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.
		if err := scanner.Err(); err != nil { // !! notice syntax
			fmt.Println("Error reading text:", err)
			continue
		}

		resp, err = SendCommand(udpAddr, cmdTypes[ct-1], txt) //Send the command
		if err != nil {
			fmt.Println("Error attempting to send command:", err)
		} else {
			fmt.Println("Got response:", resp)
		}
	}
}



//THIS IS WHERE THE PROGRAM STARTS, the home of the main() function!!!


// A simple UDP based echo client and server.
package main

import (
	"flag" //Package flag implements command-line flag parsing.
	"fmt"
	"os"
)

var (
	//pointer to flag
	help = flag.Bool(
		"help",	//flagname
		false,	//value of flag ??
		"Show usage help", //help message for flagname
	) //(*bool)
	server = flag.Bool(
		"server",
		false,
		"Start echo server if true; otherwise start the echo client",
	)
	endpoint = flag.String(
		"endpoint",
		"localhost:12110",
		"Endpoint on which server runs or to which client connects",
	)
)

func usage() {
	//func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
	fmt.Fprintf(os.Stderr, "Usage: %s [OPTIONS]\n", os.Args[0]) //if not assigned to a variable, its sent to stdout or something.
	
	//Args hold the command-line arguments, starting with the program name.
	//os.Args[0] // name of the command that it is running as
	//os.Args[1] // first command line parameter, ...
	
	fmt.Fprintf(os.Stderr, "\nOptions:\n")
	flag.PrintDefaults() //PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags.
}

func main() {
	flag.Usage = usage //Usage prints to standard error a usage message documenting all defined command-line flags. It is called when an error occurs while parsing flags.
	flag.Parse() //to parse the command line into the defined flags. Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.
	if *help {
		flag.Usage() //print help messages to os.Stderr
		os.Exit(0) //exit program, no error
	}
	if *server {
		//THIS IS THE CODE I NEED TO IMPLEMENT
		server, err := NewUDPServer(*endpoint) //localhost:12110
		check(err) //exit program with error code 1 if not able to create new UDP server
		
		//func (u *UDPServer) ServeUDP() { // is "decorated" on the server, because it is of type *UDPServer!
		server.ServeUDP() //call ServerUDP() on the returnd UDPServer returned by NewUDPServer()
		
		<-make(chan struct{}) //WHAT DOES THIS DO ?
	
	} else {
		clientLoop(*endpoint)
	}
}

func check(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error: %s\n", err.Error())
		os.Exit(1)
	}
}
